<html>
    <head>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <link href="https://fonts.cdnfonts.com/css/harry-p" rel="stylesheet">

        <style>
            body {
                font-family: sans-serif;
                cursor: url('HP_OnlyWand.png'), auto;
                background-image: url('HP_Back.png');
                background-size: cover; 
                background-repeat: no-repeat;
                background-position: center;

            }

            h1 {
                font-family: 'Harry P', sans-serif;
                font-weight: 400;
                font-size: 39pt;
                text-align: center;
                margin: 30px;
                color: white;
            }

            .axis text {
            fill: white; 
             }

       
            .axis path,
            .axis line {
                stroke: white; 
            }

            .axis-label {
                fill: white; 
            }

        </style>
    </head>
    <body>
        <h1>Deep Dive into the Dangers of the Harry Potter Universe</h1>

        <!-- Node graph -->
         <div>
            <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <title>Network Graph</title>
    <style>
        body {
            margin: 0;
            /* overflow: hidden; */
        }
        .tooltip {
            position: absolute;
            background: #f9f9f9;
            border: 1px solid #ccc;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.3);
            font-size: 12px;
            visibility: hidden;
        }
    </style>
</head>
<body>
    <svg id="graph" width="1200" height="800"></svg>
    <script>
        const spellColors = {
            "Avada Kedavra": "#28A745",
            "Confringo": "#FF4500",
            "Incendio": "#FF6347",
            "Morsmordre": "#6EBB97",
            "Sectumsempra": "#8B0000",
            "Stupefy": "#E8913D",
            "Crucio": "#48493E",
            "Imperio": "#FBD748",
            "Confundo": "#834F99",
            "Expelliarmus": "#DA3832",
            "Petrificus Totalus": "#4782B4",
            "Obliviate": "#F5DEB3",
            "Expecto patronum": "#8CCBF0"
        };
    
        const casterImages = {
            "Bellatrix Lestrange": "character_node_svg/lestrange.svg",
            "Lord Voldemort": "character_node_svg/voldemort.svg",
            "Harry Potter": "character_node_svg/potter.svg",
            "Hermione Granger": "character_node_svg/granger.svg",
            "Neville Longbottom": "character_node_svg/longbottom.svg",
            "Severus Snape": "character_node_svg/snape.svg",
            "Draco Malfoy": "character_node_svg/malfoy.svg",
            "Dolores Umbridge": "character_node_svg/umbridge.svg",
            "Peter Pettigrew": "character_node_svg/pettigrew.svg",
            "Ron Weasley": "character_node_svg/weasley.svg",
            "Albus Dumbledore": "character_node_svg/dumbledore.svg",
            "Dark Mark": "character_node_svg/dark_mark.png", // Specific image for Dark Mark
            "Unnamed Character": "character_node_svg/unknown.svg" // Specific image for Unnamed Character
        };
    
        const svg = d3.select("svg#graph");
        const graphWidth = +svg.attr("width");
        const graphHeight = +svg.attr("height");
        const imageNodeRadius = 250;
        const circleNodeRadius = 400;
    
        Promise.all([
            d3.csv("megafile.csv"), // Main data file
            d3.csv("characters.csv") // List of valid character names
        ]).then(([data, characters]) => {
            const validCharacters = new Set(characters.map(d => d.Character_Name));
    
            const castersSet = new Set(data.map(d => d.caster));
    
            const nodes = [];
            const nodeMap = new Map();
            const links = [];
    
            data.forEach(d => {
                const { caster, victim, spell_name } = d;
    
                const sourceNode = caster;
                let targetNode;
    
                // Separate "Dark Mark" as a distinct node
                if (victim === "Dark Mark") {
                    targetNode = "Dark Mark";
                } else {
                    targetNode = validCharacters.has(victim) ? victim : "Unnamed Character";
                }
    
                if (!nodeMap.has(sourceNode)) {
                    nodeMap.set(sourceNode, { id: sourceNode, isCentral: true });
                    nodes.push(nodeMap.get(sourceNode));
                }
    
                if (!nodeMap.has(targetNode)) {
                    nodeMap.set(targetNode, { id: targetNode, isCentral: castersSet.has(targetNode) });
                    nodes.push(nodeMap.get(targetNode));
                }
    
                links.push({
                    source: sourceNode,
                    target: targetNode,
                    spell: spell_name
                });
            });
    
            const link = svg.append("g")
                .attr("class", "links")
                .selectAll("path")
                .data(links)
                .join("path")
                .attr("stroke", d => spellColors[d.spell] || "#999")
                .attr("stroke-width", 2)
                .attr("fill", "none");
    
            const travelingLine = svg.append("g")
                .attr("class", "traveling-lines")
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke", d => {
                    const baseColor = d3.color(spellColors[d.spell] || "#999");
                    if (baseColor) {
                        baseColor.r = Math.min(255, baseColor.r + 50);
                        baseColor.g = Math.min(255, baseColor.g + 50);
                        baseColor.b = Math.min(255, baseColor.b + 50);
                    }
                    return baseColor;
                })
                .attr("stroke-width", 3)
                .attr("x1", -10)
                .attr("y1", 0)
                .attr("x2", 10)
                .attr("y2", 0)
                .style("visibility", "hidden");
    
            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .join("g")
                .each(function (d) {
                    const nodeGroup = d3.select(this);
                    if (casterImages[d.id]) {
                        // If there is an image for this node
                        nodeGroup.append("image")
                            .attr("xlink:href", casterImages[d.id])
                            .attr("width", 80)
                            .attr("height", 80)
                            .attr("x", -30)
                            .attr("y", -30);
                    } else {
                        nodeGroup.append("circle")
                            .attr("r", d.id === "Unnamed Character" ? 20 : 10)
                            .attr("fill", "#D5C7FF")
                            .attr("stroke", "#fff")
                            .attr("stroke-width", 1.5);
                    }
                });
    
            const simulation = d3.forceSimulation(nodes)
                .force("radial-image", d3.forceRadial(d => d.isCentral ? imageNodeRadius : circleNodeRadius, graphWidth / 2, graphHeight / 2).strength(1))
                .force("collide", d3.forceCollide().radius(d => (d.id === "Unnamed Character" ? 50 : 30)).iterations(4))
                .force("link", d3.forceLink(links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(graphWidth / 2, graphHeight / 2))
                .force("x", d3.forceX(graphWidth / 2).strength(d => (d.isCentral ? 0.5 : 0.1)))
.force("y", d3.forceY(graphHeight / 2).strength(d => (d.isCentral ? 0.5 : 0.1)))

                .on("tick", () => {
                    link.attr("d", d => {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy);
                        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                    });
    
                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                });
    
            simulation.force("link").links(links);
    
            // Tooltip for showing character names
            const tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip");
    
                node.on("mouseover", (event, d) => {
    // Always show the tooltip for all nodes (casters and victims)
    tooltip.html(d.id)
        .style("top", `${event.pageY - 20}px`)
        .style("left", `${event.pageX + 20}px`)
        .style("visibility", "visible");

    // Change cursor for casters
    if (d.isCentral) {
        d3.select("body")
            .style("cursor", "url('HP_WandH.png'), auto");

        // Highlight links connected to this caster
        link.attr("stroke-opacity", l => (l.source.id === d.id || l.target.id === d.id ? 1 : 0.1));

        // Highlight directly connected nodes
        node.selectAll("circle, image")
            .attr("opacity", n => {
                return (n.id === d.id || links.some(l => (l.source.id === d.id && l.target.id === n.id) || (l.target.id === d.id && l.source.id === n.id))) ? 1 : 0.3;
            });

        // Adjust traveling line opacity
        travelingLine.style("visibility", l => (l.source.id === d.id ? "visible" : "hidden"))
            .attr("stroke-opacity", l => (l.source.id === d.id ? 1 : 0.1));
    } else {
        d3.select("body")
            .style("cursor", "url('HP_OnlyWand.png'), auto");
    }
})
.on("mousemove", (event) => {
    // Update tooltip position
    tooltip.style("top", `${event.pageY - 20}px`)
        .style("left", `${event.pageX + 20}px`);
})
.on("mouseout", () => {
    // Reset tooltip
    tooltip.style("visibility", "hidden");

    // Reset all link, node, and traveling line opacities
    link.attr("stroke-opacity", 0.6);
    node.selectAll("circle, image").attr("opacity", 1);
    travelingLine.style("visibility", "hidden").attr("stroke-opacity", 1);

    // Reset cursor to default
    d3.select("body")
        .style("cursor", "url('HP_OnlyWand.png'), auto");
});



    
function animateSpells() {
    travelingLine
        .style("visibility", "visible")
        .attr("transform", d => `translate(${d.source.x},${d.source.y})`)
        .transition()
        .duration(1500)
        .ease(d3.easeLinear)
        .attrTween("transform", function (d) {
            const path = link.filter(l => l === d).node();
            const length = path.getTotalLength();
            return t => {
                const point = path.getPointAtLength(t * length);
                const nextPoint = path.getPointAtLength((t * length) + 1);
                const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x) * (180 / Math.PI);
                return `translate(${point.x},${point.y}) rotate(${angle})`;
            };
        })
        .on("end", function () {
            d3.select(this).style("visibility", "hidden");
        });
}

    
            setInterval(animateSpells, 2000);
        });
    </script>    


         </div>

        <!-- Bar Graph -->
        <svg id="bar-graph" height="600" width="600"></svg>
        <script>
            // Load the CSV file
            const requestData = async function() {
                const spells = await d3.csv("megafile.csv");

                // Spell Colors
                const spellColors = {
                    "Avada Kedavra": "#28A745",
                    "Confringo": "#FF4500",
                    "Incendio": "#FF6347",
                    "Morsmordre": "#6EBB97",
                    "Sectumsempra": "#8B0000",
                    "Stupefy": "#E8913D",
                    "Crucio": "#48493E",
                    "Imperio": "#FBD748",
                    "Confundo": "#834F99",
                    "Expelliarmus": "#DA3832",
                    "Petrificus Totalus": "#4782B4",
                    "Obliviate": "#F5DEB3",
                    "Expecto Patronum": "#8CCBF0"
                };

                const barWidth = 600;
                const barHeight = 600;
                const margin = { top: 20, right: 30, bottom: 100, left: 60 }; 

                // Bar Chart Dimensions
                const barSvg = d3.select("#bar-graph")
                    .attr("width", barWidth + margin.left + margin.right)
                    .attr("height", barHeight + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Calculate spell usage
                const spellUsage = d3.rollup(spells, v => v.length, d => d.spell_name);
                const spellData = Array.from(spellUsage, ([spell, count]) => ({ spell, count }));

                // Scales for the bar chart
                const x = d3.scaleBand()
                    .domain(spellData.map(d => d.spell))
                    .range([0, barWidth])
                    .padding(0.1);
                const y = d3.scaleLinear()
                    .domain([0, d3.max(spellData, d => d.count)])
                    .nice()
                    .range([barHeight, 0]);

                // Add bars to the bar chart
                barSvg.append("g")
                    .selectAll("rect")
                    .data(spellData)
                    .enter().append("rect")
                    .attr("x", d => x(d.spell))
                    .attr("y", d => y(d.count))
                    .attr("width", x.bandwidth())
                    .attr("height", d => barHeight - y(d.count))
                    .attr("fill", d => spellColors[d.spell] ); 


                // Add X and Y axes
                barSvg.append("g")
                    .attr("transform", `translate(0,${barHeight})`)
                    .call(d3.axisBottom(x))
                    .attr("class", "axis") 
                    .selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");


                barSvg.append("g").call(d3.axisLeft(y))
                    .attr("class", "axis");

                // Add axis labels
                barSvg.append("text")
                    .attr("x", barWidth / 2)
                    .attr("y", barHeight + 80)
                    .attr("text-anchor", "middle")
                    .attr("class", "axis-label")
                    .text("Spell Name");

                barSvg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -barHeight / 2)
                    .attr("y", -margin.left + 20)
                    .attr("text-anchor", "middle")
                    .attr("class", "axis-label")
                    .text("Spell Usage");
            };

            requestData();
        </script>

        <!-- Spider graph -->
        <!-- <div> -->
        <div>
            <svg id="spider-graph" height="600" width="600"></svg>
            
        </div>
            
            <script>
                const graph = d3.select('svg#spider-graph');
                const height = graph.attr('height');
                const width = graph.attr('width');

                d3.csv('norm_spell_stats.csv').then((spells) => {
                    console.log(spells)

                    let data = []
                    let features = ["Damage", "Range", "Cooldown", "Duration", "CD OOC"];
                    //generate the data
                    for (var i = 0; i < spells.length; i++){
                        var point = {}
                        //each feature will be a random number from 1-9
                        features.forEach(f => point[f] = 1 + Math.random() * 8);
                        data.push({
                            'Damage': Number(spells[i]['Damage']),
                            'Range': Number(spells[i]['Range']),
                            'Cooldown': Number(spells[i]['Cooldown']),
                            'Duration': Number(spells[i]['Duration']),
                            'CD OOC': Number(spells[i]['CD OOC'])
                        });
                    }

                    console.log(data);

                    let width = 600;
                    let height = 600;
                    let svg = d3.select("body").append("svg")
                        .attr("width", width)
                        .attr("height", height);

                        let radialScale = d3.scaleLinear()
                        .domain([0, 1])
                        .range([0, 250]);
                    let ticks = [.2, .4, .6, .8, 1.0];

                    svg.selectAll("circle")
                        .data(ticks)
                        .join(
                            enter => enter.append("circle")
                                .attr("cx", width / 2)
                                .attr("cy", height / 2)
                                .attr("fill", "none")
                                .attr("stroke", "gray")
                                .attr("r", d => radialScale(d))
                        );

                        svg.selectAll(".ticklabel")
                        .data(ticks)
                        .join(
                            enter => enter.append("text")
                                .attr("class", "ticklabel")
                                .attr("x", width / 2 + 5)
                                .attr("y", d => height / 2 - radialScale(d))
                                .text(d => d.toString())
                                .style("fill", "white")
                        );

                        function angleToCoordinate(angle, value){
                        let x = Math.cos(angle) * radialScale(value);
                        let y = Math.sin(angle) * radialScale(value);
                        return {"x": width / 2 + x, "y": height / 2 - y};
                    }   

                    let featureData = features.map((f, i) => {
                        let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
                        return {
                            "name": f,
                            "angle": angle,
                            "line_coord": angleToCoordinate(angle, 1),
                            "label_coord": angleToCoordinate(angle, 1.15)
                        };
                    });

                    // draw axis line
                    svg.selectAll("line")
                        .data(featureData)
                        .join(
                            enter => enter.append("line")
                                .attr("x1", width / 2)
                                .attr("y1", height / 2)
                                .attr("x2", d => d.line_coord.x)
                                .attr("y2", d => d.line_coord.y)
                                .attr("stroke","black")
                        );

                    // draw axis label
                    svg.selectAll(".axislabel")
                        .data(featureData)
                        .join(
                            enter => enter.append("text")
                                .attr("x", d => d.label_coord.x)
                                .attr("y", d => d.label_coord.y)
                                .text(d => d.name)
                                .style("fill", "white")
                        );

                        let line = d3.line()
                        .x(d => d.x)
                        .y(d => d.y);
                    let colors = ["#28A745", "#FF4500", "#48493E", "#DA3832", "#FBD748", "#FF6347", "#4782B4"];

                    function getPathCoordinates(data_point){
                        let coordinates = [];
                        for (var i = 0; i < features.length; i++){
                            let ft_name = features[i];
                            let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
                            coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
                        }
                        return coordinates;
                    }

                    svg.selectAll("path")
                        .data(data)
                        .join(
                            enter => enter.append("path")
                                .datum(d => getPathCoordinates(d))
                                .attr("d", line)
                                .attr("stroke-width", 3)
                                .attr("stroke", (_, i) => colors[i])
                                .attr("fill", (_, i) => colors[i])
                                .attr("stroke-opacity", 1)
                                .attr("opacity", 0.5)
                        );

                })


            </script>
        <!-- </div> -->
    </body>
</html>