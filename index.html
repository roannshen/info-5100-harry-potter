<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <title>Harry Potter Network Graph</title>
        <link href="https://fonts.cdnfonts.com/css/harry-p" rel="stylesheet">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Baskervville:ital@0;1&display=swap" rel="stylesheet">
        <style>
            body {
                font-family: "Baskervville", serif;
                cursor: url('HP_OnlyWand.png'), auto;
                background-image: url('background2.png');
                background-size: cover; 
                background-repeat: no-repeat;
                background-position: center;
                height: 100%;
                color: white;
                margin: 0;
                background-attachment: fixed;
                display: flex;
                flex-direction:column;
            }

            h1 {
                font-family: 'Harry P', sans-serif;
                font-weight: 400;
                font-size: 39pt;
                text-align: center;
                margin: 10px;
                color: white;
            }

            h2 {
                text-align: center;
                width: 100%; 
            }

            .axis text {
                font-family: "Baskervville", serif;
                font-size:8pt;
                fill: white;
            }

            .axis path,
            .axis line {
                stroke: white; 
            }

            .axis-label {
                fill: white;
                font-size: small;
            }

            .checkboxes-container {
                cursor: url('HP_OnlyWand.png'), auto;
                color: white;
                font-size: 14pt;
            }

            .checkboxes-container p {
                color: white;
                font-size: 14pt;
            }

            input, label {
                cursor: url('HP_OnlyWand.png'), auto;
            }

            .tooltip {
                position: absolute;
                background: #f9f9f9;
                border: 1px solid #ccc;
                padding: 5px;
                border-radius: 5px;
                box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.3);
                font-size: 12px;
                visibility: hidden;
                color: black;
            }

            #bar-chart-title{
                margin-top: 10px;
                margin-bottom: 10px;
            }

            #spider-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
                gap: 10px;
            }

            #checkboxes-container {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                justify-items: center;
                align-items: start;
                width: 100%;
                z-index: 1;
            }

            .checkbox-item {
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .spider-section {
                position: relative;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            .snitch-checkbox {
                position: relative;
                cursor: "url('HP_WandH.png'), auto";
                appearance: none;
                width: 30px;
                height: 30px;
                border: 2px solid rgb(222, 220, 208);
                border-radius: 4px;
                background-color: white; 
                transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out;
            }

            .snitch-checkbox:checked {
                background-color: var(--accent-color, #FFD700);
                border-color: var(--accent-color, #FFD700);
                background-image: linear-gradient(
                    rgba(0, 0, 0, 0.2),
                    rgba(0, 0, 0, 0.2)
                ); 
            }

            .snitch-checkbox::before {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 65px;
                height: 65px;
                transform: translate(-50%, -50%);
                background: url('character_node_svg/snitch.gif') no-repeat center center;
                background-size: contain;
                opacity: 0;
                transition: opacity 0.1s;
                z-index: 10;
            }

            .snitch-checkbox:checked::before {
                opacity: 1; 
            }

            #section {
            width: 100vw;
            height: 100vh;
            justify-content: flex-start;
            align-items: center;
            margin-top: 50px;
            gap: 24px;
            display: inline-flex;
            flex-direction: row;
            flex:1;
            flex-wrap: wrap; 

         }

            #row {
                width: 100%;
                display: flex;
                /* flex-direction: row; */
                /* flex-wrap: wrap; */
                flex-flow: row wrap;
                justify-content: space-around;
                align-items: flex-start;
                gap: 24px;

            }

            #left-col {
                width: 60%;
                min-width: 300px; 
                height: 100%;
                /* padding: 10px; */
                justify-content: center;
                align-items: center;
                gap: 10px;
                /* display: inline-flex; */
                flex-direction: column;
                display: flex;
                margin-left: 50px;
            }

            #right-col {
                /* margin-right: 50px; */
                min-width: 200px;
                width: 40%;
                height: 100%;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                gap: 12px;
                display: inline-flex;
                align-items: center; 
            }

            .svg {
                width: 100%;
                height: auto;
                margin-bottom: 5%;
                padding-bottom: 15%;
                /* margin-right: 5%; */
                align-self: center;
            }

            @media (max-width: 768px) { 
                /* 768 */
                #row {
                    flex-direction: column;
                    align-items: center; 
                }

                #left-col,
                #right-col {
                    width: 100%; 
                }
            }

            #legend-container {
                display: flex;
                flex-wrap: wrap; 
                flex-direction: row;
                justify-content: center; 
                gap: 10px; 
                max-width: 100%; 
                margin-top: 20px; 
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 5px;
                font-size: 10pt;
                width: 150px;
                text-align: center; 
            }

            .legend-items {
                display: flex;
                flex-direction: row;
                flex-wrap: wrap; 
                gap: 5px;
            }

            #legend-container h3 {
                font-size: 12pt;
                text-align: center;
                margin-top: 5px;
                margin-bottom: 10px;
            }


            .legend-color {
                width: 20px;
                height: 20px;
                border-radius: 5px;
            }

            .spider-right {
                margin-right: 50px;
                width: 30%;
                height: 100%;
                flex-direction: column;
                align-items: center;
                gap: 12px;
                display: inline-flex;
            }

            .spider-left {
                width: 60%;
                height: 100%;
                padding: 10px;
                align-items: center;
                gap: 10px;
                margin-left: 50px;
            }

            .spider-left h3 {
                text-align: center;
            }

            .checkbox-label {
                width: 100px;
                height: 50px;
                padding: 10px;
                color: 'white';
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: 'serif';
                font-size: 10pt;
                text-align: center;
                border-radius: 5px;
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                cursor: "url('HP_WandH.png'), auto";
            }

            #stat-features {
                text-align: center;
                padding-bottom: 30px;
            }

            #reset-button {
                background-image: url('button.svg');
                background-color: transparent;
                background-repeat: no-repeat;
                background-position: center;
                border: none;
                color: white;
                line-height: 20px;
                padding: 0 20px;
                width: 150px;
                height: 100px;
                font-size: 16px;
                font-family: 'Baskervville', serif;
                cursor: url('HP_WandH.png'), auto;
            }

            .header-section {
                text-align: center;
                width: 100%;
                justify-content: center;  
                display:flex;
                flex-direction: column;  
                align-items: center; 
                margin-bottom: 3%;
            
            }

            #graph {
            width: 100%; 
            height: 500px;
            overflow: visible; 
            }


        </style>
    </head>
<body>
    <div id="section">
        <div class="header-section">
            <h1>Deep Dive into the Dangers of the Harry Potter Universe</h1>
            <button id="reset-button">Reset Visualization</button>
        </div>
        <div id="row">
            <!-- <div id = "left-col"> -->
            <div class="spider-left">
                <svg id="graph" class="svg" height="1200" width="800"></svg>
            </div>    
            <!-- <div id="right-col"> -->
            <div class="spider-right">
                <h2 id="bar-chart-title">The Spells of the Harry Potter Universe <h2>

                <svg id="bar-graph"></svg>
                <div id="summary-stat"><p style="margin-top: 0;">Click on a character node to learn more</p></div>
                <div id="legend-container">
                    <div class="legend-items">
                        <div class="legend-item" style="color: #FFD700;"><span class="legend-color" style="background-color: #FFD700;"></span>Confringo</div>
                        <div class="legend-item" style="color: #ff7d52;"><span class="legend-color" style="background-color: #ff8652;"></span>Confundo</div>
                        <div class="legend-item" style="color: #3CB371;"><span class="legend-color" style="background-color: #3CB371;"></span>Imperio</div>
                        <div class="legend-item" style="color: #0ABAB5;"><span class="legend-color" style="background-color: #0ABAB5;"></span>Sectumsempra</div>
                        <div class="legend-item" style="color: #FFB6C1;"><span class="legend-color" style="background-color: #FFB6C1;"></span>Obliviate</div>
                        <div class="legend-item" style="color: #BA55D3;"><span class="legend-color" style="background-color: #BA55D3;"></span>Incendio</div>
                        <div class="legend-item" style="color: #1E90FF;"><span class="legend-color" style="background-color: #1E90FF;"></span>Petrificus Totalus</div>
                        <div class="legend-item" style="color: #C0C0C0;"><span class="legend-color" style="background-color: #C0C0C0;"></span>Crucio</div>
                        <div class="legend-item" style="color: #961414;"><span class="legend-color" style="background-color: #961414;"></span>Expelliarmus</div>
                        <div class="legend-item" style="color: #39FF14;"><span class="legend-color" style="background-color: #39FF14;"></span>Avada Kedavra</div>
                        <div class="legend-item" style="color: #df3737;"><span class="legend-color" style="background-color: #df3737;"></span>Stupefy</div>
                    </div>            
                </div>
            </div>
        </div>
    </div>

    <div id="section">
        <div class="header-section">
            <h1>Understanding the Spells of the Harry Potter Universe</h1>
        </div>
        <div id="row">
            <div id = "spider-left">
                <h2>Spell Stats</h2>
                <svg id="spider-graph" height="600" width="600"></svg>
                <div id="stat-features">
                    *CD OOC: Cooldown Out-Of-Combat
                </div>
            </div>
            <div class = "spider-right">
                <h2>Spells</h2>
                <div id="checkboxes-container"></div>
                <div id="spell-description" min-height="380px" width="400px"><p>Hover on a spell to learn about its abilities</p></div>
            </div>
        </div>
    </div>


<script>
    const spellColors = {
        "Avada Kedavra": "#39FF14",
        "Confringo": "#FFD700",
        "Incendio": "#BA55D3",
        "Sectumsempra": "#0ABAB5",
        "Stupefy": "#df3737",
        "Crucio": "#C0C0C0",
        "Imperio": "#3CB371",
        "Confundo": "#ff8652",
        "Expelliarmus": "#961414",
        "Petrificus Totalus": "#1E90FF",
        "Obliviate": "#FFB6C1"
    };

    const casterImages = {
        "Bellatrix Lestrange": "character_node_svg/lestrange.svg",
        "Lord Voldemort": "character_node_svg/voldemort.svg",
        "Harry Potter": "character_node_svg/potter.svg",
        "Hermione Granger": "character_node_svg/granger.svg",
        "Neville Longbottom": "character_node_svg/longbottom.svg",
        "Severus Snape": "character_node_svg/snape.svg",
        "Draco Malfoy": "character_node_svg/malfoy.svg",
        "Dolores Umbridge": "character_node_svg/umbridge.svg",
        "Peter Pettigrew": "character_node_svg/pettigrew.svg",
        "Ron Weasley": "character_node_svg/weasley.svg",
        "Albus Dumbledore": "character_node_svg/dumbledore.svg",
        "Unnamed Characters": "character_node_svg/unknown.svg"
    };

    // NODE GRAPH
    const svg = d3.select("svg#graph")
        .attr("width", "100%")
        .attr("height", "100%");

    const graphWidth = svg.node().getBoundingClientRect().width;
    const graphHeight = svg.node().getBoundingClientRect().height;
    const imageNodeRadius = 250;
    const circleNodeRadius = 350;

    const fixedPositions = {
        "Stag": { fx: 1040, fy: 690 },
        "Otter": { fx: 1100, fy: 660 }
    };

    let link, nodeGroup, selectedNode = null;
    let spellData = [];
    let spells = [];


    Promise.all([d3.csv("megafile.csv"), d3.csv("characters.csv")]).then(([data, characters]) => {
        const nodes = [];
        const links = [];
        const validCharacters = new Set(characters.map(d => d.Character_Name));
        const nodeMap = new Map();

        const houseMap = new Map();
        characters.forEach(character => {
            houseMap.set(character.Character_Name, character.House);
        });


        data.forEach(({ caster, victim, spell_name }) => {
            const sourceNode = caster;
            let targetNode = (validCharacters.has(victim) || casterImages[victim]) ? victim : "Unnamed Characters";
            if (!nodeMap.has(sourceNode)) {
                nodeMap.set(sourceNode, { id: sourceNode, isCentral: true });
                nodes.push(nodeMap.get(sourceNode));
            }
            if (!nodeMap.has(targetNode)) {
                const isFixed = fixedPositions[targetNode];
                nodeMap.set(targetNode, {
                    id: targetNode,
                    isCentral: false,
                    fx: isFixed?.fx || null,
                    fy: isFixed?.fy || null
                }); 
                nodes.push(nodeMap.get(targetNode));
            }

            nodes.forEach(node => {
                if (fixedPositions[node.id]) {
                    node.fx = fixedPositions[node.id].fx;
                    node.fy = fixedPositions[node.id].fy;
            }});

            links.push({ source: caster, target: targetNode, spell: spell_name });
        });

        links.forEach((link, index) => {
            link.index = index;
            const sameSourceTarget = links.filter(l => l.source === link.source && l.target === link.target);
            const sameTargetSource = links.filter(l => l.source === link.target && l.target === link.source);
            //Avoid overlapped links to the same person by separating the links for better visibility
            link.spacing = sameSourceTarget.indexOf(link) - sameTargetSource.length / 2;
        });

        link = svg.append("g")
            .attr("class", "links")
            .selectAll("path")
            .data(links)
            .join("path")
            .attr("stroke", d => spellColors[d.spell] || "#999")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("d", d => {
            const dx = d.target.x - d.source.x;
            const dy = d.target.y - d.source.y;
            const dr = Math.sqrt(dx * dx + dy * dy) + d.spacing * 10; //source: https://stackoverflow.com/questions/13455510/curved-line-on-d3-force-directed-tree
            return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
        });

        nodeGroup = svg.append("g").attr("class", "nodes");
        const node = nodeGroup.selectAll("g")
            .data(nodes)
            .join("g")
            .each(function (d) {
                const group = d3.select(this);
                if (casterImages[d.id]) {
                    group.append("image")
                        .attr("xlink:href", casterImages[d.id])
                        .attr("width", 55)
                        .attr("height", 55)
                        .attr("x", -20)
                        .attr("y", -20);
                } else {
                    group.append("image")
                        .attr("xlink:href", "character_node_svg/hat.svg")
                        .attr("width", 40)
                        .attr("height", 40)
                        .attr("x", -15)
                        .attr("y", -15);
                }
            });

        const sim = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(graphWidth / 2, graphHeight / 2))
            .force("x", d3.forceX(graphWidth / 2).strength(0.5))
            .force("y", d3.forceY(graphHeight / 2).strength(0.5))
            .force("radial-image", d3.forceRadial(
                d => d.isCentral ? imageNodeRadius : circleNodeRadius,
                graphWidth / 2 - 100, 
                graphHeight / 2)
                .strength(1))
            .force("collide", d3.forceCollide()
                .radius(d => (d.id === "Unnamed Characters" ? 70 : 50))
                .iterations(4));

        sim.nodes(nodes).on("tick", () => {
            node.attr("transform", d => `translate(${d.x},${d.y})`);
            link.attr("d", d => {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const dr = Math.sqrt(dx * dx + dy * dy) + d.spacing * 10;
                return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
            });
        });

        sim.force("link").links(links);

        const tooltip = d3.select("body")
                            .append("div")
                            .attr("class", "tooltip");

        node.on("mouseover", (event, d) => {
            tooltip.html(d.id)
                .style("top", `${event.pageY - 20}px`)
                .style("left", `${event.pageX + 20}px`)
                .style("visibility", "visible");
                d3.select("body")
                    .style("cursor", "url('HP_WandH.png'), auto");
                    const isCaster = data.some(row => row.caster === d.id);
            if (!isCaster) {
                d3.select("body").style("cursor", "url('HP_OnlyWand.png'), auto");
                return;
            }
            if (!selectedNode) highlightNode(d);
        }).on("mouseout", () => {
            tooltip.style("visibility", "hidden");
            d3.select("body").style("cursor", "url('HP_OnlyWand.png'), auto");
            if (!selectedNode) resetHighlight();
        });

        node.on("click", (event, d) => {
            const isCaster = data.some(row => row.caster === d.id);
            const characterName = d.id;
            const characterSpells = data.filter(row => row.caster === characterName);
            const spellCounts = d3.rollup(characterSpells, v => v.length, d => d.spell_name);
            const filteredSpellData = Array.from(spellCounts, ([spell, count]) => ({ spell, count }));
            const totalSpells = d3.sum(Array.from(spellCounts.values()));

            let mostUsedSpell = "";
            let maxCount = 0;
            spellCounts.forEach((count, spell) => {
                if (count > maxCount) {
                    maxCount = count;
                    mostUsedSpell = spell;
                }
            });

            if (!isCaster) {
                    return;
            }
            if (selectedNode && selectedNode.id === characterName) {
                selectedNode = null;
                d3.select("#bar-chart-title").text("The Spells of the Harry Potter Universe"); 
                resetBarGraph(); 
                d3.select("#summary-stat").text("Click on a character node to learn more");
            
            } else {
                selectedNode = d;
                highlightNode(d);
                d3.select("#bar-chart-title").text(`The Spells of ${d.id}`); 
                updateBarChart(filteredSpellData); // Call the function to update the bar chart
                
                // Get the character's house from the houseMap
                const house = houseMap.get(characterName) || "Unknown House";
                const summaryText = `${characterName} is a ${house} who cast ${totalSpells} spell${totalSpells !== 1 ? 's' : ''} in total, with ${mostUsedSpell} as their most used spell.`;

                // Update the #summary-stat element
                d3.select('#summary-stat').text(summaryText);
            }
        });

        // Highlighting and reset functions
        function highlightNode(node) {
            animateCurvePaths(node.id);
            
            link.attr("stroke-opacity", l =>
            l.source.id === node.id || l.target.id === node.id ? 1 : 0.1)
            .attr("stroke-width", l => l.source.id === node.id || l.target.id === node.id ? 3 : 1
            );

            // Highlight all related nodes (source or target of related links)
            nodeGroup.selectAll("image").attr("opacity", n =>
                n.id === node.id || links.some(l => l.source.id === n.id && l.target.id === node.id) || links.some(l => l.source.id === node.id && l.target.id === n.id)
                    ? 1
                    : 0.3
            );
        }

        function resetHighlight() {
            link.attr("stroke-opacity", 1).attr("stroke-width", 2);
            nodeGroup.selectAll("image").attr("opacity", 1);
        }

        //Animating spell casting and resetting animation
        function animateCurvePaths(casterId) {
            // Filter links where the caster is the source or the target
            const casterLinks = links.filter(l => l.source.id === casterId || l.target.id === casterId);

            casterLinks.forEach(linkData => {
                const path = link.filter(d => d === linkData);
                const pathElement = path.node();
                const length = pathElement.getTotalLength();

                // I learned to animate links from source: https://hackernoon.com/animating-line-charts-with-d3js
                path.attr("stroke-dasharray", `${length} ${length}`)
                    .attr("stroke-dashoffset", length)
                    .transition()
                    .duration(1500)
                    .ease(d3.easeLinear)
                    .attr("stroke-dashoffset", 0);
            });
        }   

        function resetCurvePaths() {
            link.attr("stroke-dasharray", null).attr("stroke-dashoffset", null);
        }

        function resetHighlight() {
            link.attr("stroke-opacity", 1).attr("stroke-width", 2);
            nodeGroup.selectAll("image").attr("opacity", 1);
        }

        function updateBarChart(filteredSpellData) {
            const spellCountMap = new Map(filteredSpellData.map(d => [d.spell, d.count]));
            const allSpellsData = spellData.map(d => ({
                spell: d.spell,
                count: spellCountMap.get(d.spell) || 0 
            }));

            d3.select("#bar-graph").selectAll("*").remove();

            const barWidth = 400;
            const barHeight = 200;
            const margin = { top: 20, right: 30, bottom: 100, left: 50 };

            const barSvg = d3.select("#bar-graph")
                .attr("width", barWidth + margin.left + margin.right)
                .attr("height", barHeight + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand()
                .domain(allSpellsData.map(d => d.spell))
                .range([0, barWidth])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(allSpellsData, d => d.count)]) 
                // .domain([0, 45]) //stays same entire time
                .nice()
                .range([barHeight, 0]);
            
            const tooltip = d3.select("body")
                        .append("div")
                        .attr("class", "tooltip");

            barSvg.selectAll("rect")
                .data(allSpellsData)
                .enter().append("rect")
                .attr("x", d => x(d.spell))
                .attr("y", d => y(d.count))
                .attr("width", x.bandwidth())
                .attr("height", d => barHeight - y(d.count))
                .attr("fill", d => spellColors[d.spell])
                .on("mouseover", (event, d) => {
                tooltip.style("visibility", "visible")
                    .text(`Usage: ${d.count}`);
                d3.select(event.target).style("cursor", "url('HP_WandH.png'), auto"); 
                })
                .on("mousemove", event => {
                    tooltip.style("top", `${event.pageY - 10}px`)
                .style("left", `${event.pageX + 10}px`);
                })
                .on("mouseout", () => {
                    tooltip.style("visibility", "hidden");
                });

            // Add X and Y axes
            barSvg.append("g")
                .attr("transform", `translate(0,${barHeight})`)
                .call(d3.axisBottom(x))
                .attr("class", "axis")
                .selectAll("text")
                .attr("dy", "0.75em") 
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

            barSvg.append("g")
                .call(d3.axisLeft(y))
                .attr("dy", "0.35em") 
                .attr("class", "axis");

                // Add axis labels
            barSvg.append("text")
                .attr("x", barWidth / 2)
                .attr("y", barHeight + 95) 
                .attr("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Spell Name");

            barSvg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -barHeight / 2)
                .attr("y", -margin.left + 15) 
                .attr("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Spell Usage");

        }

        function resetBarGraph() {
            d3.select("#bar-graph").selectAll("*").remove();

            const barWidth = 400;
            const barHeight = 200;
            const margin = { top: 20, right: 30, bottom: 100, left: 50 };

            // Bar Chart Dimensions
            const barSvg = d3.select("#bar-graph")
                .attr("width", barWidth + margin.left + margin.right)
                .attr("height", barHeight + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Calculate spell usage
            const spellUsage = d3.rollup(data, v => v.length, d => d.spell_name);
            spellData = Array.from(spellUsage, ([spell, count]) => ({ spell, count })).sort((a, b) => a.count - b.count);

            // Scales for the bar chart
            const x = d3.scaleBand()
                .domain(spellData.map(d => d.spell))
                .range([0, barWidth])
                .padding(0.1);
            const y = d3.scaleLinear()
                .domain([0, d3.max(spellData, d => d.count)])
                .nice()
                .range([barHeight, 0]);

            const tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip");

            barSvg.append("g")
                .selectAll("rect")
                .data(spellData)
                .enter().append("rect")
                .attr("x", d => x(d.spell))
                .attr("y", d => y(d.count))
                .attr("width", x.bandwidth())
                .attr("height", d => barHeight - y(d.count))
                .attr("fill", d => spellColors[d.spell])
                .on("mouseover", (event, d) => {
                tooltip.style("visibility", "visible")
                    .text(`Usage: ${d.count}`);
                d3.select(event.target).style("cursor", "url('HP_WandH.png'), auto"); 
                })
                .on("mousemove", event => {
                    tooltip.style("top", `${event.pageY - 10}px`)
                .style("left", `${event.pageX + 10}px`);
                })
                .on("mouseout", () => {
                    tooltip.style("visibility", "hidden");
                });

            barSvg.append("g")
                .attr("transform", `translate(0,${barHeight})`)
                .call(d3.axisBottom(x))
                .attr("class", "axis")
                .selectAll("text")
                .attr("dy", "0.75em") 
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

            barSvg.append("g")
                .call(d3.axisLeft(y))
                .attr("dy", "0.35em")
                .attr("class", "axis");

            barSvg.append("text")
                .attr("x", barWidth / 2)
                .attr("y", barHeight + 95)
                .attr("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Spell Name");

            barSvg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -barHeight / 2)
                .attr("y", -margin.left + 15) 
                .attr("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Spell Usage");
        }

        //RESET 
        document.getElementById("reset-button").addEventListener("click", resetVisualization);

        function resetVisualization() {
            // Reset selectedNode to null
            selectedNode = null;
            d3.select("#bar-chart-title").text("The Spells of the Harry Potter Universe");
            d3.select("#summary-stat").text("Click on a character node to learn more");

            // Reset the graph
            resetHighlight();
            resetCurvePaths();

            // Reset the bar chart
            resetBarGraph();
        }
    });

    // BAR GRAPH
    const requestData = async function() {
        const spells = await d3.csv("megafile.csv");
        const barWidth = 400;
        const barHeight = 200;
        const margin = { top: 20, right: 30, bottom: 100, left: 50 };

        // Bar Chart Dimensions
        const barSvg = d3.select("#bar-graph")
            .attr("width", barWidth + margin.left + margin.right)
            .attr("height", barHeight + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Calculate spell usage
        const spellUsage = d3.rollup(spells, v => v.length, d => d.spell_name);
        spellData = Array.from(spellUsage, ([spell, count]) => ({ spell, count }));
        spellData.sort((a, b) => a.count - b.count);
        // Scales for the bar chart
        const x = d3.scaleBand()
            .domain(spellData.map(d => d.spell))
            .range([0, barWidth])
            .padding(0.1);
        const y = d3.scaleLinear()
            .domain([0, d3.max(spellData, d => d.count)])
            .nice()
            .range([barHeight, 0]);
        
        const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip");

        // Add bars to the bar chart
        barSvg.append("g")
            .selectAll("rect")
            .data(spellData)
            .enter().append("rect")
            .attr("x", d => x(d.spell))
            .attr("y", d => y(d.count))
            .attr("width", x.bandwidth())
            .attr("height", d => barHeight - y(d.count))
            .attr("fill", d => spellColors[d.spell])
            .on("mouseover", (event, d) => {
                tooltip.style("visibility", "visible")
                    .text(`Usage: ${d.count}`);
                d3.select(event.target).style("cursor", "url('HP_WandH.png'), auto");
                })
                .on("mousemove", event => {
                    tooltip.style("top", `${event.pageY - 10}px`)
                .style("left", `${event.pageX + 10}px`);
                })
                .on("mouseout", () => {
                    tooltip.style("visibility", "hidden");
                });

        barSvg.append("g")
            .attr("transform", `translate(0,${barHeight})`)
            .call(d3.axisBottom(x))
            .attr("class", "axis")
            .selectAll("text")
            .attr("dy", "0.75em")
            .attr("transform", "rotate(-45)")
            .style("text-anchor", "end");

        barSvg.append("g")
            .call(d3.axisLeft(y))
            .attr("dy", "0.35em") 
            .attr("class", "axis");

        // Add axis labels
        barSvg.append("text")
            .attr("x", barWidth / 2)
            .attr("y", barHeight + 95) 
            .attr("text-anchor", "middle")
            .attr("class", "axis-label")
            .text("Spell Name");

        barSvg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("x", -barHeight / 2)
            .attr("y", -margin.left + 15) 
            .attr("text-anchor", "middle")
            .attr("class", "axis-label")
            .text("Spell Usage");

    }

        requestData();
        
</script>

<!-- SPIDER GRAPH -->
            
<script>
    const maxSelected = 8;
    let selectedSpells = ['Avada Kedavra', 'Confringo'];
    const spellsNames = ['Avada Kedavra', 'Confringo', 'Crucio', 'Imperio', 'Incendio', 'Expelliarmus', 'Petrificus Totalus']
    let spellDataMap = {};

    const tooltip = d3.select("body")
                        .append("div")
                        .attr("class", "tooltip");

    const descriptionBox = d3.select("#spell-description")

    function createCheckboxes(spellNames, spellDataMap) {
        const checkboxesContainer = d3.select('#checkboxes-container');
        checkboxesContainer.selectAll('*').remove();

        const checkboxes = checkboxesContainer.selectAll('div')
            .data(spellNames)
            .enter()
            .append('div')
            .attr('class', 'checkbox-item')
            .style('padding', '10px 15px')
            .style('display', 'flex')
            .style('align-items', 'center');

        checkboxes.append('input')
            .attr('type', 'checkbox')
            .attr('id', d => d)
            .attr('value', d => d)
            .attr('class', 'snitch-checkbox')
            .property('checked', (d, i) => i === 0 || i === 1)
            .style('height', '30px')
            .style('width', '30px')
            .each(function (d) {
                const accentColor = spellColors[d];
                this.style.setProperty('--accent-color', accentColor);
            })
            .style('cursor', "url('HP_WandH.png'), auto")
            .on('mouseover', function(event, d) {
                if (!this.checked) {
                    d3.select(this).style('background-color', 'gray');
                }
                
                    descriptionBox.style("visibility", "visible") 
                        .style('width', '400px') 
                        .style('height', '380px')
                        .html(`<span style="font-weight: bold;">${d}:</span> <span>${spellDataMap[d]}</span>`);  
                })
            .on('mouseout', function() {
                if (!this.checked) {
                    d3.select(this).style('background-color', 'white');
                }
                descriptionBox.style("visibility", "visible").text("Hover on a spell to learn about its abilities");
            })
            .on('change', function(event, d) {
                const accentColor = spellColors[d];
                handleCheckboxChange(event)
                d3.select(this)
                    .style('background-color', this.checked ? accentColor : 'white')
            });

        checkboxes.append('label')
            .attr('for', d => d)
            .attr('class', 'checkbox-label')
            .style('background-image', d => `url('button.svg')`)
            .text(d => d)
            .on('mouseover', function(event, d) {
                descriptionBox.style("visibility", "visible") 
                    .style('width', '400px') 
                    .style('height', '380px')
                    .html(`<span style="font-weight: bold;">${d} Spell:</span> <span style="font-weight: normal;">${spellDataMap[d]}</span>`);  
            })
            .on('mouseout', function() {
                descriptionBox.style("visibility", "visible").text("Hover on a spell to learn about its abilities")
                .style('justify-content', 'center');
            });
    }

    function handleCheckboxChange(event) {
        const spellName = event.target.value;

        if (event.target.checked) {
            if (selectedSpells.length < maxSelected) {
                event.target.checked = true;
                selectedSpells.push(spellName);
            } else {
            event.target.checked = false;
            alert("You can select up to 3 spells only.");
            }
        } else {
            selectedSpells = selectedSpells.filter(spell => spell !== spellName);
        }

        drawSpiderChart(selectedSpells);
    }

    function updateSpiderChart(selectedSpells) {
        const filteredStats = selectedSpells.map(spell => ({
            spell: spell,
            stats: spellStats[spell]
    }));

    d3.select('#spider-chart').selectAll('*').remove();
        drawSpiderChart(selectedSpells);
    }

    d3.csv('spell_descriptions.csv').then(data => {
        data.forEach(spell => {
            spellDataMap[spell.Name] = spell.Description;
        });

        createCheckboxes(spellsNames, spellDataMap);
    })

    
    function drawSpiderChart(spellsList) {
        d3.csv('norm_spell_stats.csv').then((spells) => {
            // Cite: We used https://yangdanny97.github.io/blog/2019/03/01/D3-Spider-Chart to learn how to graph spider graphs
            let data = [];
            let features = ["Damage", "Range", "Cooldown", "Duration", "CD OOC"];
            
            for (let i = 0; i < spells.length; i++) {
                if (spellsList.includes(spells[i]['Name'])) {
                    data.push({
                        'Name': spells[i]['Name'],
                        'Damage': Number(spells[i]['Damage']),
                        'Range': Number(spells[i]['Range']),
                        'Cooldown': Number(spells[i]['Cooldown']),
                        'Duration': Number(spells[i]['Duration']),
                        'CD OOC': Number(spells[i]['CD OOC'])
                    });
                }
            }

            let svg = d3.select('svg#spider-graph');
            const width = 600;
            const height = 600;
            svg.selectAll("circle").remove();
            svg.selectAll(".ticklabel").remove();
            svg.selectAll("line").remove();
            svg.selectAll(".axislabel").remove();
            svg.selectAll("path").remove();
            svg.selectAll("*").remove();
            
            let radialScale = d3.scaleLinear()
                .domain([0, 1])
                .range([0, Math.min(width, height) / 2 - 100]); 
            let ticks = [.2, .4, .6, .8, 1.0];

            svg.selectAll("circle")
                .data(ticks)
                .enter()
                .append("circle")
                .attr("cx", width / 2)
                .attr("cy", height / 2)
                .attr("fill", "none")
                .attr("stroke", "gray")
                .attr("r", d => radialScale(d));

            svg.selectAll(".ticklabel")
                .data(ticks)
                .enter()
                .append("text")
                .attr("x", width / 2 + 5)
                .attr("y", d => height / 2 - radialScale(d))
                .text(d => (d*10).toString())
                .style("fill", "white");

            function angleToCoordinate(angle, value) {
                let x = Math.cos(angle) * radialScale(value);
                let y = Math.sin(angle) * radialScale(value);
                return { "x": width / 2 + x, "y": height / 2 - y }; 
            }

            let featureData = features.map((f, i) => {
                let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
                return {
                    "name": f,
                    "angle": angle,
                    "line_coord": angleToCoordinate(angle, 1),
                    "label_coord": angleToCoordinate(angle, 1.2)
                };
            });

            // Draw feature axes
            svg.selectAll("line")
                .data(featureData)
                .enter()
                .append("line")
                .attr("x1", width / 2)
                .attr("y1", height / 2)
                .attr("x2", d => d.line_coord.x)
                .attr("y2", d => d.line_coord.y)
                .attr("stroke", "white");

            // Draw axis labels
            svg.selectAll(".axislabel")
                .data(featureData)
                .enter()
                .append("text")
                .attr("x", d => d.label_coord.x)
                .attr("y", d => d.label_coord.y)
                .text(d => d.name)
                .style("fill", "white")
                .style("text-anchor", "middle");

            // Line generator function
            let line = d3.line()
                .x(d => d.x)
                .y(d => d.y);

            // Convert data point to coordinates
            function getPathCoordinates(data_point) {
                let coordinates = [];
                for (let i = 0; i < features.length; i++) {
                    let ft_name = features[i];
                    let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
                    coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
                }
                return coordinates;
            }

            const paths = svg.selectAll("path")
                .data(data, d => d.Name);

            paths.exit().remove();

            paths.enter()
                .append("path")
                .merge(paths)
                .attr("d", d => line(getPathCoordinates(d)))
                .attr("stroke-width", 3)
                .attr("stroke", d => spellColors[d['Name']])
                .attr("fill", d => spellColors[d['Name']])
                .attr("stroke-opacity", 1)
                .attr("opacity", 0.5)
                .style('cursor', "url('HP_WandH.png'), auto")
                .on('mouseover', function(event, d) {
                    tooltip.style("visibility", "visible")  
                        .text(d['Name']);
                })
                .on('mousemove', function(event) {
                    tooltip.style("top", `${event.pageY - 10}px`) 
                        .style("left", `${event.pageX + 10}px`);
                })
                .on('mouseout', function() {
                    tooltip.style("visibility", "hidden");
                });
        });
    }

    drawSpiderChart(selectedSpells)

</script>
</body>
</html>